Go for Javaneros

* A bit of history of Go

* Why Go?

* Compilation

** Go is compiled

Generates an executable binary.

Deploying = copying.

Cross compilation to deploy to other architectures.

** Java is compiled-ish, sometimes

Java is compiled to Java bytecode
Java bytecode is sometimes compiled, other times interpreted

Deploying = copying bytecode + installing JVM where needed.

No need of cross compilation.
Easy integration with other langauges.

I've heard "I hate Java, I love the JVM"

** So

deploying = Go wins
interoperability with other languages = Java wins

And anyways, is Python a compiled language?

`.pyc` files contain Python bytecode, that sounds like .class!

"Python is an interpreted language, as opposed to a compiled one, though the distinction can be blurry because of the presence of the bytecode compiler. This means that source files can be run directly without explicitly creating an executable which is then run."

* Questions

- Does Java have pointers?
- Are Java parameters passed by value or reference?

* Answer

No, java doesn't have pointers.

	Person john = new Person("John", 20);
	Person anne = new Person("Anne", 30);

Parameters are passed by value.

	void swapName(a String, b String) {
		String tmp = b;
		a = b;
		b = a;
	}
	swapName(a.Name, b.Name);

Except for classes, those are passed by reference.

	void swapPersonName(a Person, b Person) {
		String tmp = b.Name;
		b.Name = a.Name;
		a.Name = tmp;
	}
	swapPersonName(a, b);

Passed by reference is something else

	void swapPerson(a Person, b Person) {
		Person tmp = b;
		b = a;
		a = tmp;
	}
	swapPerson(a, b);

* So

- Does Java have pointers? Yes, but they're hidden
- Are Java parameters passed by value or reference? Value

For more on this: http://javadude.com/articles/passbyvalue.htm

* And Go?

- Does Go have pointers? Yes
- Are Go parameters passed by value or reference? Value

Given the type Person:

	type Person struct {
		Name string
		Age int
	}

Swapping two strings doesn't change anything

	func SwapName(a, b string) {
		a, b = b, a
	}
	SwapName(a.Name, b.Name)

Swapping the name of two Person doesn't change anything

	func SwapPersonName(a, b Person) {
		a.Name, b.Name = b.Name, a.Name
	}
	SwapPersonname(a, b)

Swapping two Persons doesn't change anything

	func SwapPerson(a, b Person) {
		a, b = b, a
	}
	SwapPerson(a, b)

With pointers though:

	func SwapName(a, b *string) {
		*a, *b = *b, *a
	}

	func SwapPersonName(a, b *Person) {
		a.Name, b.Name = b.Name, a.Name
	}

	func SwapPerson(a, b *Person) {
		*a, *b = *b, *a
	}


* Type system

- Class oriented vs Type oriented
- Inheritance vs Composition
- Explicit vs Implicit satisfaction of interfaces

** Methods

*** Java

Methods are defined as part of classes.

	public class Programmer {
		private int caffeineLevel;

		public void drinkCoffee() {
			this.caffeineLevel++;
		}
		public bool isAwake() {
			return this.caffeineLevel > 42;
		}
	}

*** Go

Methods are defined on any type.

	type Programmer struct {
		caffeineLevel int
	}
	func (p *Programmer) DrinkCoffee() {
		p.caffeineLevel++
	}
	func (p *Programmer) isAwake() bool {
		return p.caffeineLevel > 42
	}

We can define methods on any type, as long it's defined in the same package.

	type MyInt int
	func (m MyInt) Sum(int x) MyInt { return m + MyInt(x)}

** Interfaces

*** Java

	package doer

	interface Doer {
		void Do() throws Exception
	}
 
	package mydoer

	// TODO: revise imports in Java
	import doer

	class MyDoer implements Doer {
		void Do() throws Exception { ... }
	}

MyDoer *depends* on Doer. Therefore we can define a class that implements a given interface,
but given a type it's impossible to use it as an interface that the type doesn't depend on.



* Java: It's inheritance all the way!

The Dog is-an Animal is not something we don't model often in SI.

Often inheritance is used to expose part of another class behavior.

	public class Engine (extends Object) {
		public start() {
			...
		}
		public stop() {
			...
		}
	}

	// We can start and stop a car, so ... it makes sense
	public class Car extends Engine {
	}

So Car is-an Engine. Say what?

* Java: Composition is possible

Composition models this better:

	public class Car {
		private Engine engine;

		public start() {
			this.engine.start()
		}

		public stop() {
			this.engine.stop()
		}
	}

But it feels too verbose!

* Go: Composition

	type Engine struct { ... }
	func (e Engine) Start() { ... }
	func (e Engine) Stop() { ... }

	type Car struct {
		e Engine
	}
	func (c Car) Start() { c.e.Start() }
	func (c Car) Stop() { c.e.Stop() }

* Go: struct embedding

	type Car struct {
		Engine
	}

Boom!

** From Effective Java

	// Broken - Inappropriate use of inheritance!
	public class InstrumentedHashSet<E> extends HashSet<E> {
		// The number of attempted element insertions
		private int addCount = 0;
		public InstrumentedHashSet() {}

		public InstrumentedHashSet(int initCap, float loadFactor) {
			super(initCap, loadFactor);
		}

		@Override public boolean add(E e) {
			addCount++;
			return super.add(e);
		}
		@Override public boolean addAll(Collection<? extends E> c) {
			addCount += c.size();
			return super.addAll(c);
		}
		public int getAddCount() {
			return addCount;
		}
	}

This class looks reasonable, but it doesnâ€™t work. Suppose we create an instance and add three elements using the addAll method:

	InstrumentedHashSet<String> s = new InstrumentedHashSet<String>();
	s.addAll(Arrays.asList("Snap", "Crackle", "Pop"));

Count will be 6, because addAll class add in HashSet ... oh shit.

Solution

	// Wrapper class - uses composition in place of inheritance
	public class InstrumentedSet<E> extends ForwardingSet<E> {
		 private int addCount = 0;
		 public InstrumentedSet(Set<E> s) {
		 	super(s);
		 }
		 @Override public boolean add(E e) {
		 	addCount++;
		 	return super.add(e);
		 }
		 @Override public boolean addAll(Collection<? extends E> c) {
		 	addCount += c.size();
		 	return super.addAll(c);
		 }
		 public int getAddCount() {
		 	return addCount;
		 }
	}

And then we need this amazing code.

	// Reusable forwarding class
	public class ForwardingSet<E> implements Set<E> {
		 private final Set<E> s;

		 public ForwardingSet(Set<E> s) { this.s = s; }

		 public void clear() { s.clear(); }
		 public boolean contains(Object o) { return s.contains(o); }
		 public boolean isEmpty() { return s.isEmpty(); }
		 public int size() { return s.size(); }
		 public Iterator<E> iterator() { return s.iterator(); }
		 public boolean add(E e) { return s.add(e); }
		 public boolean remove(Object o) { return s.remove(o); }
		 public boolean containsAll(Collection<?> c) { return s.containsAll(c); }
		 public boolean addAll(Collection<? extends E> c) {return s.addAll(c); }
		 public boolean removeAll(Collection<?> c) { return s.removeAll(c); }
		 public boolean retainAll(Collection<?> c) { return s.retainAll(c); }
		 public Object[] toArray() { return s.toArray(); }
		 public <T> T[] toArray(T[] a) { return s.toArray(a); }
		 @Override public boolean equals(Object o) { return s.equals(o); }
		 @Override public int hashCode() { return s.hashCode(); }
		 @Override public String toString() { return s.toString(); }
	}

*** Equivalent code in Go

Assuming we had an equivalent Set type, with equivalent operations, specially:

	func (s *HashSet) Add(v interface{}) { ... }
	func (s *HashSet) AddAll(v ...interface{}) { ... }

Then InstrumentedHashSet would be simply:

	type InstrumentedHashSet struct {
		*Set
		addCount int
	}
	func (s *InstrumentedHashSet) Add(v interface{}) {
		s.addCount++
		s.Set.Add(v)
	}
	func (s *InstrumentedHashSet) AddAll(vs ...interface{}) {
		s.addCount += len(vs)
		s.Set.AddAll(vs...)
	}


* Partial inheritance?

* Java: hiding methods that are public on the parent

	public class UnstoppableCar extends Car {
		private stop() { ... }
	}

NOPE

* Go: Struct embedding of interfaces

	type starter interface {
		Start()
	}

	type UnstoppableCar struct {
		Starter
	}

	func main() {
		uc := UnstoppableCar{Engine{}}
	}

* Multiple inheritance

Java: no!

Go: yes :)