Go for Javaneros
 #go4java

Francesc Campoy
Gopher and Developer Advocate
Google
@francesc

* Go and Java common aspects

Go and Java are

- object oriented.

- garbage collected.

- statically typed.

- part of the C family.

* Object oriented flavors

Go is Object Oriented, but doesn't have any of the keywords:

- `class`,
- `extends`, or
- `implements`.

* Call by value, by reference, and pointers

* Q1: Are Java parameters passed by value or reference?

Options:

a) everything is passed by reference.

b) everything is passed by value.

c) objects by reference, others by value.

* Q2: Does Java have pointers?

Options:

a) No

b) Nope

* a) everything is passed by reference?

False!

.code go4java/ValueRef.java /doubleInt/,/$^/

At least primitive types are passed by value.

* b) everything is passed by value?

Given the class `MyInteger`:

.code go4java/ValueRef.java /MyInteger/,/$^/

Objects are not passed by value, since they can be modified.

.code go4java/ValueRef.java /doubleMyInteger/,/$^/

* c) objects by reference, others by value!

Well ... no!

.code go4java/ValueRef.java /replaceMyInteger/,/$^/

In Java everything is passed by value.

Objects are references to values, copies refer to the same values.

* What about Go?

Go has pointers,

- but no pointer arithmetics.

Parameters are passed by value,

- and two copies of a pointer point to the same space in memory.

* Pointers on primitive types

Pointers allow the function to modify the original variable.

.code go4java/valueref/valueref.go /func DoubleInt\(/
.code go4java/valueref/valueref.go /func DoubleIntPtr/

.code go4java/valueref/valueref_test.go /:= 2/,/3:/

* Other types

Go doesn't have classes, but it has structs.

.code go4java/valueref/valueref.go /struct/,/^}/

And the same behavior applies.

.code go4java/valueref/valueref.go /func DoubleMyInteger/
.code go4java/valueref/valueref.go /func DoubleMyIntegerPtr/

.code go4java/valueref/valueref_test.go /:= MyInteger/,/3:/

* So

Go has pointers and everything is passed by value.

Just like Java!

.image go4java/img/pointer.png

* Declaring methods

What we said about parameters also applies to method receivers.

A method on `MyInteger` receives a copy:

.code go4java/valueref/valueref.go /MyInteger\) Double\(\)/

.code go4java/valueref/valueref_test.go /ExampleMyIntegerDouble/,/Println/

A method on `*MyInteger` receives a copy of a pointer:

.code go4java/valueref/valueref.go /MyInteger\) DoublePtr\(\)/

.code go4java/valueref/valueref_test.go /ExampleMyIntegerDoublePtr/,/Println/

* Declaring methods on other types

We can define methods on any type declared on the same package.

But we can define a new type `MyInt` based on `int`.

.code go4java/valueref/valueref.go /type MyInt /

And then define methods on both `MyInt`:

.code go4java/valueref/valueref.go /MyInt\) Double/

.code go4java/valueref/valueref_test.go /ExampleByIntDouble/,/Println/

And `*MyInt`:

.code go4java/valueref/valueref.go /MyInt\) DoublePtr/

.code go4java/valueref/valueref_test.go /ExampleByIntDoublePtr/,/Println/

* Declaring methods on nil pointers

`String` returns a string with the description of the `Book`.

.code go4java/books/books.go /type Book/,/^}/

.code go4java/books/books.go /Book\) String/

`Author` contains `First` and `Last` names, but `String` first checks if the receiver is nil.

.code go4java/books/books.go /type Author/,/^}/

.code go4java/books/books.go /Author\) String/,/^}/

* Declaring methods on nil pointers (continued)

With a non nil `Author`:

.code go4java/books/books_test.go /potter := /,/by/

With a nil `Author`:

.code go4java/books/books_test.go /cool := /,/by/

* Interfaces

* Interfaces

An interface is a set of methods.

In Java:

	interface Switch {
		void open();
		void close();
	}

In Go:

	type OpenCloser interface {
		Open()
		Close()
	}

* It's all about satisfaction

Java interfaces are satisfied *explicitly*.

Go interfaces are satisfied *implicitly*.

.image go4java/img/satisfaction.jpg 400 600

* Java: explicit satisfaction = "implements"

`printHiTo` needs an object with the method `void`print(String)`

.code go4java/InterfaceSat.java /START_PRINT_TO/,/END_PRINT_TO/

`System.out` has that method, let's use it!

.code go4java/InterfaceSat.java /START_BAD/,/END_BAD/

Fails with:

	error: incompatible types: PrintStream cannot be converted to StringPrinter
	    static StringPrinter sp = System.out;

* Solution #1

Approach: 

- Modify `PrintStream` in the Java standard library.
- Add `implements StringPrinter`.

	class PrintStream implements Closeable, Flushable, Appendable, AutoCloseable, StringPrinter

Result:

- Shame and dependencies.

* Solution #2

Approach:

- Create an anonymous class implementing `StringPrinter`

Result:

Boilerplate in every call.

.code go4java/InterfaceSat.java /new StringPrinter/,/\}\)/

* Solution #3

Approach:

- Add a new class that implements `StringPrinter` given a `PrinterStream`

.code go4java/InterfaceSat.java /START_MyStringPrinter/,/END_MyStringPrinter/

Result:

Boilerplate to create the class, but calls are short.

.code go4java/InterfaceSat.java /new MyStringPrinter/

* Go: implicit satisfaction = no "implements"

If a type defines all the methods of an interface, the type satisfies that interface.

.code go4java/interfaces.go /Writer/,/^}/

.code go4java/interfaces.go /PrintHiTo/,/^}/

`os.Stdout` is a `*os.File`, which defines `Write` among other methods.

	func (f *File) Write(b []byte) (n int, err error)

* Go: implicit satisfaction = no "implements"

Since

- `*os.File` has all the methods that `MyWriter` requires

we know that

- `*os.File` is a `MyWriter`.

Therefore we can simply write:

.code go4java/interfaces.go /os.Stdout/

This is named *structural*subtyping*.

Think duck typing checked at compilation time.

* Inheritance vs composition

* Inheritance vs composition

Lots of articles have been written about the topic.

In general, composition is preferred to inheritance.

Lets see why.

* Task

.code go4java/BadInheritance.java /START_TASK/,/END_TASK/

* Runner

.code go4java/BadInheritance.java /START_RUNNER/,/END_RUNNER/

* CountingRunner is-a Runner that counts

.code go4java/BadInheritance.java /START_COUNTING/,/END_COUNTING/

* Let's run and count

What will this code print?

.code go4java/BadInheritance.java /START_MAIN/,/END_MAIN/

Of course, this prints:

	running one
	running two
	running three
	my runner ran 6 tasks

Wait! How many?

* My runner ran 6 tasks? Six?

Inheritance causes:

- weak encapsulation,
- tightly coupling,
- surprising bugs.

.image go4java/img/countingrunner.png

* Solution: use composition

.code go4java/Composition.java /START_COUNTING/,/BREAK_COUNTING/

* Solution: use composition (continued)

.code go4java/Composition.java /BREAK_COUNTING/,/END_COUNTING/

* Solution: use composition (continued)

*Pros*

- The bug is gone!
- `Runner` is completely independent of `CountingRunner`.
- The creation of the `Runner` can be delayed until (and if) needed.

*Cons*

- Composition doesn't define any methods on `CountingRunner`:

	public String getName() { return runner.getName(); }

- This can cause lots of repetition, and eventually bugs.

* There's no inheritance in Go

* There's no inheritance in Go

Let's use composition directly:

.code go4java/runner/runner.go /type Task/,/END_TASK/

`Task` and `Runner` are very similar to the Java version.

.code go4java/runner/runner.go /type Runner/,/END_RUNNER/

* CountingRunner

`CountingRunner` has a `Runner` field.

.code go4java/runner/runner.go /type CountingRunner/,

* Composition in Go

Same pros and cons as the composition version in Java.

We also have the boilerplate to proxy methods from `Runner`.

.code go4java/runner/runner.go /runner.Name/

But we can remove it!

* Struct embedding

Materialized as unnamed fields in a struct.

It is still *composition*.

The methods of the embedded type become methods of the embedding type.

* Example of struct embedding

Given a type `Person`:

.code go4java/embedsample.go /Person/,/Hi/

We can define a type `Employee` embedding `Person`:

.code go4java/embedsample.go /Employee/,/}/

All fields and methods from `Person` are available on `Employee`:

.code go4java/embedsample.go /var/,/Introduce/

* Struct embedding

.code go4java/runner/embed.go /type EmbeddingCountingRunner/,

* Is struct embedding like inheritance?

No, it's better!

- It is composition
- Struct embedding of interfaces exports only a set of the methods of the embedded value.

TODO: find example, compare to Java hiding inherited methods (private inheritance)

* Lambdas

* Improving Runner

We could make our `Runner` example more generic using interfaces.

.code go4java/Lambdas.java /START/,/END/

And then call `run` with an anonymous interface.

.code go4java/Lambdas.java /ANONYMOUS/,/LAMBDA/

* Lambdas

Lambda expressions let you express instances of single-method classes more compactly

- Lambda expressions generate interface instances.
- They have a better syntax than anonymous interfaces.

The code:

.code go4java/Lambdas.java /new Task/,/LAMBDA/

is equivalent to:

.code go4java/Lambdas.java /lambda/

* Lambdas in Go: function values

Functions are first class citizens in Go.

Variables can hold functions:

	sum := func(x, y int) int { return x + y }

Functions can return functions:

.code go4java/funcs.go /adder/,/^}/

Functions all around:

.code go4java/funcs.go /START/,/END/

* Lambdas in Go: function values

`Runner` now runs functions of type `func()`.

.code go4java/taskrunner/taskrunner.go /func.*Runner\) Run/,/^}/

We can call `Run` with a literal function.

.code go4java/taskrunner/taskrunner_test.go /NewRunner/,/Println/

* Lambdas in Go: method values

Or using the `Task` type we defined before:

.code go4java/taskrunner/taskrunner.go /type Task/,

`t.Run` is a method value of type `func()`.

.code go4java/taskrunner/taskrunner_test.go /method/,/t.Run/

* Concurrency
